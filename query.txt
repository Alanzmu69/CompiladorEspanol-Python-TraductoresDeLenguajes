crea un analizador sintactico para este analizador lexico ya establecido: 

class AnalizadorLexico:
    def __init__(self):
        self.RESERVADAS = ['nulo', 'entero', 'decimal', 'palabra', 'logico', 'constante', 'desde', 'si', 'hasta', 'mientras',
                           'regresa', 'hacer', 'sino', 'incr', 'imprime', 'imprimenl', 'lee', 'repite', 'que']
        self.OPERADORES_LOGICOS = ['no', 'y', 'o']
        self.CONSTANTES_LOGICAS = ['verdadero', 'falso']
        self.OPERADORES_ARITMETICOS = ['+', '-', '*', '/', '%', '^']
        self.DELIMITADORES = [';', ',', '(', ')', '{', '}', '[', ']', ':', '=']
        self.DELIMITADORES_UNIVERSALES = [' ', '\t', '\n']
        self.OPERADORES_RELACIONALES = ['<', '>', '<=', '>=', '<>', '==']
        self.pos = -1
        self.texto = ''
        self.char_actual = None
        self.linea_actual = 1
        self.posicion_actual = 0
        self.tokens = []

    def avanzar(self):
        self.pos += 1
        if self.pos < len(self.texto):
            if self.char_actual == '\n':
                self.linea_actual += 1
                self.posicion_actual = 0
            else:
                self.posicion_actual += 1
            self.char_actual = self.texto[self.pos]
        else:
            self.char_actual = None

    def crear_digitos(self):
        str_num = ''
        puntos = 0
        while self.char_actual is not None and (self.char_actual.isdigit() or self.char_actual == '.'):
            if self.char_actual == '.':
                if puntos == 1:
                    break
                puntos += 1
                str_num += '.'
            else:
                str_num += self.char_actual
            self.avanzar()

        if puntos == 0:
            return ('ENTERO', int(str_num))
        else:
            return ('DECIMAL', float(str_num))

    def crear_cadena(self):
        str_cadena = ''
        self.avanzar()  # Avanza sobre la comilla inicial

        while self.char_actual is not None and self.char_actual != '"':
            str_cadena += self.char_actual
            self.avanzar()

        if self.char_actual == '"':
            self.avanzar()  # Avanza sobre la comilla final
            return ('CADENA', str_cadena)
        else:
            raise SyntaxError(f"Cadena de texto no cerrada en la línea {self.linea_actual}, posición {self.posicion_actual}")

    def analizar(self, input_text):
        self.pos = -1
        self.texto = input_text
        self.char_actual = None
        self.linea_actual = 1
        self.posicion_actual = 0
        self.avanzar()
        self.tokens = []
        en_comentario = False

        while self.char_actual is not None:
            # Comentarios de una línea
            if self.char_actual == '/' and self.pos + 1 < len(self.texto) and self.texto[self.pos + 1] == '/':
                # Ignora todo hasta el final de la línea
                while self.char_actual is not None and self.char_actual != '\n':
                    self.avanzar()
                self.avanzar()  # Avanza sobre el último '\n'
            # Comentarios de varias líneas
            elif self.char_actual == '/' and self.pos + 1 < len(self.texto) and self.texto[self.pos + 1] == '*':
                en_comentario = True
                self.avanzar()  # Avanza sobre el '*'
                self.avanzar()  # Avanza sobre el '/'
            elif en_comentario and self.char_actual == '*' and self.pos + 1 < len(self.texto) and self.texto[self.pos + 1] == '/':
                en_comentario = False
                self.avanzar()  # Avanza sobre el '*'
                self.avanzar()  # Avanza sobre el '/'
            elif not en_comentario:
                if self.char_actual in self.DELIMITADORES_UNIVERSALES:
                    self.avanzar()
                elif self.char_actual.isdigit():
                    self.tokens.append(self.crear_digitos())
                elif self.char_actual in self.OPERADORES_ARITMETICOS:
                    self.tokens.append(('OP_ARITMETICO', self.char_actual))
                    self.avanzar()
                elif self.char_actual in self.OPERADORES_RELACIONALES:
                    # Verificamos si el próximo caracter también forma parte del operador relacional
                    if self.pos + 1 < len(self.texto) and self.char_actual + self.texto[self.pos + 1] in self.OPERADORES_RELACIONALES:
                        self.tokens.append(('OP_RELACIONAL', self.char_actual + self.texto[self.pos + 1]))
                        self.avanzar()
                    else:
                        self.tokens.append(('OP_RELACIONAL', self.char_actual))
                    self.avanzar()
                elif self.char_actual.isalpha() or self.char_actual == '_':
                    id = ''
                    while self.char_actual is not None and (self.char_actual.isalnum() or self.char_actual == '_'):
                        id += self.char_actual
                        self.avanzar()
                    if id in self.RESERVADAS:
                        self.tokens.append(('RESERVADA', id))  # Las palabras reservadas son tokens
                    elif id in self.OPERADORES_LOGICOS:
                        self.tokens.append(('OP_LOGICO', id))
                    elif id in self.CONSTANTES_LOGICAS:
                        self.tokens.append(('CONST_LOGICA', id))
                    else:
                        self.tokens.append(('VARIABLE', id))
                elif self.char_actual == '"':
                    self.tokens.append(self.crear_cadena())
                elif self.char_actual in self.DELIMITADORES:
                    self.tokens.append(('DELIMITADOR', self.char_actual))
                    self.avanzar()
                else:
                    raise SyntaxError(f"Caracter inesperado '{self.char_actual}' en la línea {self.linea_actual}, posición {self.posicion_actual}")
            else:
                self.avanzar()

        if en_comentario:
            raise SyntaxError("Comentario de múltiples líneas no cerrado.")

        return self.tokens
    

codigo_fuente = '''
aqui va el programa de prueba
'''
analizador_lexico = AnalizadorLexico()
tokens = analizador_lexico.analizar(codigo_fuente)

print(tokens)



La gramatica EBNF es la siguiente: 


programa ::= {declaracion} funcion funcion_principal

declaracion ::= (calificador_constante)? declaracion_variable | declaracion_funcion

calificador_constante ::= 'constante'

declaracion_variable ::= tipo identificador {',' identificador} ('=' expresion)? ';'

tipo ::= 'nulo' | 'entero' | 'decimal' | 'palabra' | 'logico'

identificador ::= char {char | digit}

expresion ::= numero | cadena | logico | identificador | operacion_aritmetica | operacion_logica | operacion_relacional

numero ::= digit {digit} | digit {digit} '.' digit {digit}

cadena ::= '"' {char} '"'

logico ::= 'verdadero' | 'falso'

operacion_aritmetica ::= expresion operador_aritmetico expresion

operador_aritmetico ::= '+' | '-' | '*' | '/' | '%' | '^'

operacion_logica ::= expresion operador_logico expresion

operador_logico ::= 'no' | 'y' | 'o'

operacion_relacional ::= expresion operador_relacional expresion

operador_relacional ::= '<' | '>' | '<=' | '>=' | '<>' | '=='

declaracion_funcion ::= tipo identificador '(' lista_parametros ')' sentencia_compuesta

lista_parametros ::= [tipo identificador {',' tipo identificador}]

sentencia_compuesta ::= '{' sentencia {sentencia} '}'

sentencia ::= sentencia_expresion | sentencia_seleccion | sentencia_iteracion | sentencia_imprimir | sentencia_retorno | sentencia_asignacion

sentencia_expresion ::= expresion ';'

sentencia_seleccion ::= 'si' '(' expresion ')' 'hacer' sentencia_compuesta ('sino' sentencia_compuesta)?

sentencia_iteracion ::= ('desde' expresion 'hasta' expresion 'incr' expresion | 'mientras que' expresion | 'repite' {sentencia} 'hasta que' expresion) sentencia_compuesta

sentencia_imprimir ::= ('imprime' | 'imprimenl') '(' expresion ')' ';'

sentencia_retorno ::= 'regresa' expresion ';'

sentencia_asignacion ::= identificador '=' expresion ';'

funcion_principal ::= 'nulo principal() ' sentencia_compuesta


debe tener la capacidad de analizar sintacticamente programas como el siguiente:


constante entero TAM=10;
entero i, j, k=10, vec[TAM]={12, -1, 0, 99, 18, 23, 55, 10, 25, 30};
palabra p="Hola";
logico band=falso;
constante decimal PI=3.141592;

nulo ordBurbuja(entero *arr, entero n) {
	entero i, j, tmp;
  desde i=0 hasta n-2 incr 1
     j=i+1;
     mientras que j<=n-1 {
        si arr[i] > arr[j] hacer {
           tmp = arr[i];
           arr[i] = arr[j];
			  arr[j] = tmp;
        }
        j = j + 1;
      }
}
nulo impVec(entero *arr, entero n) {
	entero i=0;
  imprime("vec=[");
  repite {
     imprime(arr[i], ", ");
     i =  i+ 1
  } hasta que i == n;
  imprimenl(arr[n-1], "]");
}

entero facRec(entero num) {
   si num == 0 o num == 1 hacer regresa 1;
   sino regresa num * facRec(num-1);
}

logico compara(decimal a, decimal b) {
    regresa a > b;
}

decimal areaCir(decimal radio) {
    regresa PI*radio^2;
}

palabra concatena(palabra a, palabra b) {
    regresa a + " " + b;
}

nulo principal() {
   imprime("Dame numero: ");
   lee(i);
   imprimenl("Factorial(", i, ")=", facRec(i)); 
} 

ten en cuenta los todos enunciados en la gramatica para hacer el analizador sintactico (si, repite, desde), tambien ten en cuenta el analizador lexico y como funciona, para hacer el sintactico, ten cuidado como nombras las variables para que no haya errores
ademas ten en cuenta que los tokens por parte del analizador lexico salen de esta manera para el programa de prueba:

[('RESERVADA', 'constante'), ('RESERVADA', 'entero'), ('VARIABLE', 'TAM'), ('DELIMITADOR', '='), ('ENTERO', 10), ('DELIMITADOR', ';'), ('RESERVADA', 'entero'), ('VARIABLE', 'i'), ('DELIMITADOR', ','), ('VARIABLE', 'j'), ('DELIMITADOR', ','), ('VARIABLE', 'k'), ('DELIMITADOR', '='), ('ENTERO', 10), ('DELIMITADOR', ','), ('VARIABLE', 'vec'), ('DELIMITADOR', '['), ('VARIABLE', 'TAM'), ('DELIMITADOR', ']'), ('DELIMITADOR', '='), ('DELIMITADOR', '{'), ('ENTERO', 12), ('DELIMITADOR', ','), ('OP_ARITMETICO', '-'), ('ENTERO', 1), ('DELIMITADOR', ','), ('ENTERO', 0), ('DELIMITADOR', ','), ('ENTERO', 99), ('DELIMITADOR', ','), ('ENTERO', 18), ('DELIMITADOR', ','), ('ENTERO', 23), ('DELIMITADOR', ','), ('ENTERO', 55), ('DELIMITADOR', ','), ('ENTERO', 10), ('DELIMITADOR', ','), ('ENTERO', 25), ('DELIMITADOR', ','), ('ENTERO', 30), ('DELIMITADOR', '}'), ('DELIMITADOR', ';'), ('RESERVADA', 'palabra'), ('VARIABLE', 'p'), ('DELIMITADOR', '='), ('CADENA', 'Hola'), ('DELIMITADOR', ';'), ('RESERVADA', 'logico'), ('VARIABLE', 'band'), ('DELIMITADOR', '='), ('CONST_LOGICA', 'falso'), ('DELIMITADOR', ';'), ('RESERVADA', 'constante'), ('RESERVADA', 'decimal'), ('VARIABLE', 'PI'), ('DELIMITADOR', '='), ('DECIMAL', 3.141592), ('DELIMITADOR', ';'), ('RESERVADA', 'nulo'), ('VARIABLE', 'ordBurbuja'), ('DELIMITADOR', '('), ('RESERVADA', 'entero'), ('OP_ARITMETICO', '*'), ('VARIABLE', 'arr'), ('DELIMITADOR', ','), ('RESERVADA', 'entero'), ('VARIABLE', 'n'), ('DELIMITADOR', ')'), ('DELIMITADOR', '{'), ('RESERVADA', 'entero'), ('VARIABLE', 'i'), ('DELIMITADOR', ','), ('VARIABLE', 'j'), ('DELIMITADOR', ','), ('VARIABLE', 'tmp'), ('DELIMITADOR', ';'), ('RESERVADA', 'desde'), ('VARIABLE', 'i'), ('DELIMITADOR', '='), ('ENTERO', 0), ('RESERVADA', 'hasta'), ('VARIABLE', 'n'), ('OP_ARITMETICO', '-'), ('ENTERO', 2), ('RESERVADA', 'incr'), ('ENTERO', 1), ('VARIABLE', 'j'), ('DELIMITADOR', '='), ('VARIABLE', 'i'), ('OP_ARITMETICO', '+'), ('ENTERO', 1), ('DELIMITADOR', ';'), ('RESERVADA', 'mientras'), ('RESERVADA', 'que'), ('VARIABLE', 'j'), ('OP_RELACIONAL', '<='), ('VARIABLE', 'n'), ('OP_ARITMETICO', '-'), ('ENTERO', 1), ('DELIMITADOR', '{'), ('RESERVADA', 'si'), ('VARIABLE', 'arr'), ('DELIMITADOR', '['), ('VARIABLE', 'i'), ('DELIMITADOR', ']'), ('OP_RELACIONAL', '>'), ('VARIABLE', 'arr'), ('DELIMITADOR', '['), ('VARIABLE', 'j'), ('DELIMITADOR', ']'), ('RESERVADA', 'hacer'), ('DELIMITADOR', '{'), ('VARIABLE', 'tmp'), ('DELIMITADOR', '='), ('VARIABLE', 'arr'), ('DELIMITADOR', '['), ('VARIABLE', 'i'), ('DELIMITADOR', ']'), ('DELIMITADOR', ';'), ('VARIABLE', 'arr'), ('DELIMITADOR', '['), ('VARIABLE', 'i'), ('DELIMITADOR', ']'), ('DELIMITADOR', '='), ('VARIABLE', 'arr'), ('DELIMITADOR', '['), ('VARIABLE', 'j'), ('DELIMITADOR', ']'), ('DELIMITADOR', ';'), ('VARIABLE', 'arr'), ('DELIMITADOR', '['), ('VARIABLE', 'j'), ('DELIMITADOR', ']'), ('DELIMITADOR', '='), ('VARIABLE', 'tmp'), ('DELIMITADOR', ';'), ('DELIMITADOR', '}'), ('VARIABLE', 'j'), ('DELIMITADOR', '='), ('VARIABLE', 'j'), ('OP_ARITMETICO', '+'), ('ENTERO', 1), ('DELIMITADOR', ';'), ('DELIMITADOR', '}'), ('DELIMITADOR', '}'), ('RESERVADA', 'nulo'), ('VARIABLE', 'impVec'), ('DELIMITADOR', '('), ('RESERVADA', 'entero'), ('OP_ARITMETICO', '*'), ('VARIABLE', 'arr'), ('DELIMITADOR', ','), ('RESERVADA', 'entero'), ('VARIABLE', 'n'), ('DELIMITADOR', ')'), ('DELIMITADOR', '{'), ('RESERVADA', 'entero'), ('VARIABLE', 'i'), ('DELIMITADOR', '='), ('ENTERO', 0), ('DELIMITADOR', ';'), ('RESERVADA', 'imprime'), ('DELIMITADOR', '('), ('CADENA', 'vec=['), ('DELIMITADOR', ')'), ('DELIMITADOR', ';'), ('RESERVADA', 'repite'), ('DELIMITADOR', '{'), ('RESERVADA', 'imprime'), ('DELIMITADOR', '('), ('VARIABLE', 'arr'), ('DELIMITADOR', '['), ('VARIABLE', 'i'), ('DELIMITADOR', ']'), ('DELIMITADOR', ','), ('CADENA', ', '), ('DELIMITADOR', ')'), ('DELIMITADOR', ';'), ('VARIABLE', 'i'), ('DELIMITADOR', '='), ('VARIABLE', 'i'), ('OP_ARITMETICO', '+'), ('ENTERO', 1), ('DELIMITADOR', '}'), ('RESERVADA', 'hasta'), ('RESERVADA', 'que'), ('VARIABLE', 'i'), ('DELIMITADOR', '='), ('DELIMITADOR', '='), ('VARIABLE', 'n'), ('DELIMITADOR', ';'), ('RESERVADA', 'imprimenl'), ('DELIMITADOR', '('), ('VARIABLE', 'arr'), ('DELIMITADOR', '['), ('VARIABLE', 'n'), ('OP_ARITMETICO', '-'), ('ENTERO', 1), ('DELIMITADOR', ']'), ('DELIMITADOR', ','), ('CADENA', ']'), ('DELIMITADOR', ')'), ('DELIMITADOR', ';'), ('DELIMITADOR', '}'), ('RESERVADA', 'entero'), ('VARIABLE', 'facRec'), ('DELIMITADOR', '('), ('RESERVADA', 'entero'), ('VARIABLE', 'num'), ('DELIMITADOR', ')'), ('DELIMITADOR', '{'), ('RESERVADA', 'si'), ('VARIABLE', 'num'), ('DELIMITADOR', '='), ('DELIMITADOR', '='), ('ENTERO', 0), ('OP_LOGICO', 'o'), ('VARIABLE', 'num'), ('DELIMITADOR', '='), ('DELIMITADOR', '='), ('ENTERO', 1), ('RESERVADA', 'hacer'), ('RESERVADA', 'regresa'), ('ENTERO', 1), ('DELIMITADOR', ';'), ('RESERVADA', 'sino'), ('RESERVADA', 'regresa'), ('VARIABLE', 'num'), ('OP_ARITMETICO', '*'), ('VARIABLE', 'facRec'), ('DELIMITADOR', '('), ('VARIABLE', 'num'), ('OP_ARITMETICO', '-'), ('ENTERO', 1), ('DELIMITADOR', ')'), ('DELIMITADOR', ';'), ('DELIMITADOR', '}'), ('RESERVADA', 'logico'), ('VARIABLE', 'compara'), ('DELIMITADOR', '('), ('RESERVADA', 'decimal'), ('VARIABLE', 'a'), ('DELIMITADOR', ','), ('RESERVADA', 'decimal'), ('VARIABLE', 'b'), ('DELIMITADOR', ')'), ('DELIMITADOR', '{'), ('RESERVADA', 'regresa'), ('VARIABLE', 'a'), ('OP_RELACIONAL', '>'), ('VARIABLE', 'b'), ('DELIMITADOR', ';'), ('DELIMITADOR', '}'), ('RESERVADA', 'decimal'), ('VARIABLE', 'areaCir'), ('DELIMITADOR', '('), ('RESERVADA', 'decimal'), ('VARIABLE', 'radio'), ('DELIMITADOR', ')'), ('DELIMITADOR', '{'), ('RESERVADA', 'regresa'), ('VARIABLE', 'PI'), ('OP_ARITMETICO', '*'), ('VARIABLE', 'radio'), ('OP_ARITMETICO', '^'), ('ENTERO', 2), ('DELIMITADOR', ';'), ('DELIMITADOR', '}'), ('RESERVADA', 'palabra'), ('VARIABLE', 'concatena'), ('DELIMITADOR', '('), ('RESERVADA', 'palabra'), ('VARIABLE', 'a'), ('DELIMITADOR', ','), ('RESERVADA', 'palabra'), ('VARIABLE', 'b'), ('DELIMITADOR', ')'), ('DELIMITADOR', '{'), ('RESERVADA', 'regresa'), ('VARIABLE', 'a'), ('OP_ARITMETICO', '+'), ('CADENA', ' '), ('OP_ARITMETICO', '+'), ('VARIABLE', 'b'), ('DELIMITADOR', ';'), ('DELIMITADOR', '}'), ('RESERVADA', 'nulo'), ('VARIABLE', 'principal'), ('DELIMITADOR', '('), ('DELIMITADOR', ')'), ('DELIMITADOR', '{'), ('RESERVADA', 'imprime'), ('DELIMITADOR', '('), ('CADENA', 'Dame numero: '), ('DELIMITADOR', ')'), ('DELIMITADOR', ';'), ('RESERVADA', 'lee'), ('DELIMITADOR', '('), ('VARIABLE', 'i'), ('DELIMITADOR', ')'), ('DELIMITADOR', ';'), ('RESERVADA', 'imprimenl'), ('DELIMITADOR', '('), ('CADENA', 'Factorial('), ('DELIMITADOR', ','), ('VARIABLE', 'i'), ('DELIMITADOR', ','), ('CADENA', ')='), ('DELIMITADOR', ','), ('VARIABLE', 'facRec'), ('DELIMITADOR', '('), ('VARIABLE', 'i'), ('DELIMITADOR', ')'), ('DELIMITADOR', ')'), ('DELIMITADOR', ';'), ('DELIMITADOR', '}')]